/**
  ******************************************************************************
  * @file    main.cpp
  * @author  Auto-generated by STM32CubeIDE
  * @author  topin89@mail.ru (Mikhail Gorodetsky)
  * @version V1.0
  ******************************************************************************
*/

/*
    MIT License

    Copyright (c) 2020 Mikhail Mikhailovich Gorodetsky

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

using size_t = unsigned int;
using uint32_t = unsigned int;
using uint16_t = unsigned short int;
using uint8_t = unsigned char;


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#ifdef __cplusplus
  #define   __I     volatile             /*!< Defines 'read only' permissions */
#else
  #define   __I     volatile const       /*!< Defines 'read only' permissions */
#endif
#define     __O     volatile             /*!< Defines 'write only' permissions */
#define     __IO    volatile             /*!< Defines 'read / write' permissions */

/* following defines should be used for structure members */
#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */

constexpr size_t SCS_BASE     = (0xE000E000UL);                            /*!< System Control Space Base Address */
constexpr size_t NVIC_BASE    = (SCS_BASE +  0x0100UL);                    /*!< NVIC Base Address */
constexpr size_t SCB_BASE     = (SCS_BASE +  0x0D00UL);                    /*!< System Control Block Base Address */

constexpr size_t PERIPH_BASE     = 0x40000000UL; /*!< Peripheral base address in the alias region                                */
constexpr size_t APB1PERIPH_BASE = PERIPH_BASE;
constexpr size_t AHB1PERIPH_BASE = (PERIPH_BASE + 0x00020000UL);
constexpr size_t FLASH_R_BASE    = (AHB1PERIPH_BASE + 0x3C00UL);
constexpr size_t RCC_BASE        = (AHB1PERIPH_BASE + 0x3800UL);
constexpr size_t PWR_BASE        = (APB1PERIPH_BASE + 0x7000UL);
constexpr size_t GPIOA_BASE      = (AHB1PERIPH_BASE + 0x0000UL);
constexpr size_t GPIOD_BASE      = (AHB1PERIPH_BASE + 0x0C00UL);
constexpr size_t TIM2_BASE       = (APB1PERIPH_BASE + 0x0000UL);

//If someone knows how to make constexpr pointers from adresses,
//let me know
#define FLASH (reinterpret_cast<__IO FLASH_TypeDef * const>(FLASH_R_BASE))
#define RCC  (reinterpret_cast<__IO RCC_TypeDef * const>(RCC_BASE))
#define PWR  (reinterpret_cast<__IO PWR_TypeDef * const>(PWR_BASE))
#define GPIOD  (reinterpret_cast<__IO GPIO_TypeDef * const>(GPIOD_BASE))
#define TIM2 (reinterpret_cast<__IO TIM_TypeDef * const>(TIM2_BASE))
#define NVIC (reinterpret_cast<__IO NVIC_Type * const>(NVIC_BASE))   /*!< NVIC configuration struct */
#define SCB  (reinterpret_cast<__IO SCB_Type * const>(SCB_BASE))   /*!< SCB configuration struct */

typedef struct
{
  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
  __IOM uint32_t VTOR;                   /*!< Offset: 0x008 (R/W)  Vector Table Offset Register */
  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
  __IOM uint8_t  SHP[12U];               /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
  __IOM uint32_t CFSR;                   /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register */
  __IOM uint32_t HFSR;                   /*!< Offset: 0x02C (R/W)  HardFault Status Register */
  __IOM uint32_t DFSR;                   /*!< Offset: 0x030 (R/W)  Debug Fault Status Register */
  __IOM uint32_t MMFAR;                  /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register */
  __IOM uint32_t BFAR;                   /*!< Offset: 0x038 (R/W)  BusFault Address Register */
  __IOM uint32_t AFSR;                   /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register */
  __IM  uint32_t PFR[2U];                /*!< Offset: 0x040 (R/ )  Processor Feature Register */
  __IM  uint32_t DFR;                    /*!< Offset: 0x048 (R/ )  Debug Feature Register */
  __IM  uint32_t ADR;                    /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register */
  __IM  uint32_t MMFR[4U];               /*!< Offset: 0x050 (R/ )  Memory Model Feature Register */
  __IM  uint32_t ISAR[5U];               /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register */
        uint32_t RESERVED0[5U];
  __IOM uint32_t CPACR;                  /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register */
} SCB_Type;

struct FLASH_TypeDef
{
  __IO uint32_t ACR;      /*!< FLASH access control register,   Address offset: 0x00 */
  __IO uint32_t KEYR;     /*!< FLASH key register,              Address offset: 0x04 */
  __IO uint32_t OPTKEYR;  /*!< FLASH option key register,       Address offset: 0x08 */
  __IO uint32_t SR;       /*!< FLASH status register,           Address offset: 0x0C */
  __IO uint32_t CR;       /*!< FLASH control register,          Address offset: 0x10 */
  __IO uint32_t OPTCR;    /*!< FLASH option control register ,  Address offset: 0x14 */
  __IO uint32_t OPTCR1;   /*!< FLASH option control register 1, Address offset: 0x18 */
};

struct RCC_TypeDef
{
  __IO uint32_t CR;            /*!< RCC clock control register,                                  Address offset: 0x00 */
  __IO uint32_t PLLCFGR;       /*!< RCC PLL configuration register,                              Address offset: 0x04 */
  __IO uint32_t CFGR;          /*!< RCC clock configuration register,                            Address offset: 0x08 */
  __IO uint32_t CIR;           /*!< RCC clock interrupt register,                                Address offset: 0x0C */
  __IO uint32_t AHB1RSTR;      /*!< RCC AHB1 peripheral reset register,                          Address offset: 0x10 */
  __IO uint32_t AHB2RSTR;      /*!< RCC AHB2 peripheral reset register,                          Address offset: 0x14 */
  __IO uint32_t AHB3RSTR;      /*!< RCC AHB3 peripheral reset register,                          Address offset: 0x18 */
  uint32_t      RESERVED0;     /*!< Reserved, 0x1C                                                                    */
  __IO uint32_t APB1RSTR;      /*!< RCC APB1 peripheral reset register,                          Address offset: 0x20 */
  __IO uint32_t APB2RSTR;      /*!< RCC APB2 peripheral reset register,                          Address offset: 0x24 */
  uint32_t      RESERVED1[2];  /*!< Reserved, 0x28-0x2C                                                               */
  __IO uint32_t AHB1ENR;       /*!< RCC AHB1 peripheral clock register,                          Address offset: 0x30 */
  __IO uint32_t AHB2ENR;       /*!< RCC AHB2 peripheral clock register,                          Address offset: 0x34 */
  __IO uint32_t AHB3ENR;       /*!< RCC AHB3 peripheral clock register,                          Address offset: 0x38 */
  uint32_t      RESERVED2;     /*!< Reserved, 0x3C                                                                    */
  __IO uint32_t APB1ENR;       /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */
  __IO uint32_t APB2ENR;       /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */
  uint32_t      RESERVED3[2];  /*!< Reserved, 0x48-0x4C                                                               */
  __IO uint32_t AHB1LPENR;     /*!< RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */
  __IO uint32_t AHB2LPENR;     /*!< RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */
  __IO uint32_t AHB3LPENR;     /*!< RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */
  uint32_t      RESERVED4;     /*!< Reserved, 0x5C                                                                    */
  __IO uint32_t APB1LPENR;     /*!< RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */
  __IO uint32_t APB2LPENR;     /*!< RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */
  uint32_t      RESERVED5[2];  /*!< Reserved, 0x68-0x6C                                                               */
  __IO uint32_t BDCR;          /*!< RCC Backup domain control register,                          Address offset: 0x70 */
  __IO uint32_t CSR;           /*!< RCC clock control & status register,                         Address offset: 0x74 */
  uint32_t      RESERVED6[2];  /*!< Reserved, 0x78-0x7C                                                               */
  __IO uint32_t SSCGR;         /*!< RCC spread spectrum clock generation register,               Address offset: 0x80 */
  __IO uint32_t PLLI2SCFGR;    /*!< RCC PLLI2S configuration register,                           Address offset: 0x84 */
};

struct PWR_TypeDef
{
  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
} ;

struct GPIO_TypeDef
{
  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00      */
  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04      */
  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08      */
  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C      */
  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10      */
  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14      */
  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18      */
  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C      */
  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
} ;

struct TIM_TypeDef
{
  __IO uint32_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
  __IO uint32_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
  __IO uint32_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
  __IO uint32_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
  __IO uint32_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
  __IO uint32_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
  __IO uint32_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
  __IO uint32_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
  __IO uint32_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
  __IO uint32_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
  __IO uint32_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
  __IO uint32_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
  __IO uint32_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
  __IO uint32_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
  __IO uint32_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
} ;

struct NVIC_Type
{
  __IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
        uint32_t RESERVED0[24U];
  __IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
        uint32_t RSERVED1[24U];
  __IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
        uint32_t RESERVED2[24U];
  __IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
        uint32_t RESERVED3[24U];
  __IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
        uint32_t RESERVED4[56U];
  __IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
        uint32_t RESERVED5[644U];
  __OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
};

constexpr uint32_t SCB_SCR_SEVONPEND_Pos = 4U;                                            /*!< SCB SCR: SEVONPEND Position */
constexpr uint32_t SCB_SCR_SEVONPEND_Msk = (1UL << SCB_SCR_SEVONPEND_Pos);                 /*!< SCB SCR: SEVONPEND Mask */

constexpr uint32_t FLASH_ACR_PRFTEN_Pos = 8U;
constexpr uint32_t FLASH_ACR_PRFTEN_Msk = (0x1UL << FLASH_ACR_PRFTEN_Pos);          /*!< 0x00000100 */
constexpr uint32_t FLASH_ACR_PRFTEN     = FLASH_ACR_PRFTEN_Msk;
constexpr uint32_t FLASH_ACR_ICEN_Pos   = (9U);
constexpr uint32_t FLASH_ACR_ICEN_Msk   = (0x1UL << FLASH_ACR_ICEN_Pos);            /*!< 0x00000200 */
constexpr uint32_t FLASH_ACR_ICEN       = FLASH_ACR_ICEN_Msk;
constexpr uint32_t FLASH_ACR_DCEN_Pos   = (10U);
constexpr uint32_t FLASH_ACR_DCEN_Msk   = (0x1UL << FLASH_ACR_DCEN_Pos);            /*!< 0x00000400 */
constexpr uint32_t FLASH_ACR_DCEN       = FLASH_ACR_DCEN_Msk;


constexpr uint32_t PWR_CR_VOS_Pos = (14U);
constexpr uint32_t PWR_CR_VOS_Msk = (0x1UL << PWR_CR_VOS_Pos);                   /*!< 0x00004000 */
constexpr uint32_t PWR_CR_VOS     = PWR_CR_VOS_Msk;                              /*!< VOS bit (Regulator voltage scaling output selection) */

constexpr uint32_t PWR_REGULATOR_VOLTAGE_SCALE1 = PWR_CR_VOS;             /* Scale 1 mode(default value at reset): the maximum value of fHCLK = 168 MHz. */

constexpr uint32_t RCC_APB1ENR_PWREN_Pos = 28U;
constexpr uint32_t RCC_APB1ENR_PWREN_Msk = (0x1UL << RCC_APB1ENR_PWREN_Pos);     /*!< 0x10000000 */
constexpr uint32_t RCC_APB1ENR_PWREN     = RCC_APB1ENR_PWREN_Msk;

constexpr uint32_t RCC_CR_HSITRIM_Pos = 3U;
constexpr uint32_t RCC_CR_HSITRIM_Msk = 0x1FUL << RCC_CR_HSITRIM_Pos;       /*!< 0x000000F8 */
constexpr uint32_t RCC_CR_HSITRIM     = RCC_CR_HSITRIM_Msk;

constexpr uint32_t RCC_HSICALIBRATION_DEFAULT = 0x10U;         /* Default HSI calibration trimming value */

constexpr uint32_t RCC_CFGR_PPRE1_Pos = (10U);
constexpr uint32_t RCC_CFGR_PPRE1_Msk = (0x7UL << RCC_CFGR_PPRE1_Pos);        /*!< 0x00001C00 */
constexpr uint32_t RCC_CFGR_PPRE1     = RCC_CFGR_PPRE1_Msk;                  /*!< PRE1[2:0] bits (APB1 prescaler) */

constexpr uint32_t RCC_CFGR_PPRE1_DIV16 = 0x00001C00U;                         /*!< HCLK divided by 16 */
constexpr uint32_t RCC_HCLK_DIV16       = RCC_CFGR_PPRE1_DIV16;

constexpr uint32_t RCC_CFGR_PPRE2_Pos = (13U);
constexpr uint32_t RCC_CFGR_PPRE2_Msk = (0x7UL << RCC_CFGR_PPRE2_Pos);        /*!< 0x0000E000 */
constexpr uint32_t RCC_CFGR_PPRE2 = RCC_CFGR_PPRE2_Msk;                  /*!< PRE2[2:0] bits (APB2 prescaler) */

constexpr uint32_t RCC_CFGR_HPRE_Pos = (4U);
constexpr uint32_t RCC_CFGR_HPRE_Msk = (0xFUL << RCC_CFGR_HPRE_Pos);         /*!< 0x000000F0 */
constexpr uint32_t RCC_CFGR_HPRE     = RCC_CFGR_HPRE_Msk;                   /*!< HPRE[3:0] bits (AHB prescaler) */

constexpr uint32_t RCC_CFGR_HPRE_DIV1 = 0x00000000U;                         /*!< SYSCLK not divided    */
constexpr uint32_t RCC_SYSCLK_DIV1    = RCC_CFGR_HPRE_DIV1;

constexpr uint32_t RCC_CFGR_SW_HSI      = 0x00000000U;                         /*!< HSI selected as system clock */
constexpr uint32_t RCC_SYSCLKSOURCE_HSI = RCC_CFGR_SW_HSI;

constexpr uint32_t RCC_CFGR_SW_Pos = (0U);
constexpr uint32_t RCC_CFGR_SW_Msk = (0x3UL << RCC_CFGR_SW_Pos);           /*!< 0x00000003 */
constexpr uint32_t RCC_CFGR_SW     = RCC_CFGR_SW_Msk;                     /*!< SW[1:0] bits (System clock Switch) */

constexpr uint32_t RCC_CFGR_PPRE1_DIV1 = 0x00000000U;                         /*!< HCLK not divided   */
constexpr uint32_t RCC_CFGR_PPRE1_DIV2 = 0x00001000U;                         /*!< HCLK divided by 2  */

constexpr uint32_t RCC_HCLK_DIV1 = RCC_CFGR_PPRE1_DIV1;
constexpr uint32_t RCC_HCLK_DIV2 = RCC_CFGR_PPRE1_DIV2;


constexpr uint32_t RCC_AHB1ENR_GPIOAEN_Pos = (0U);
constexpr uint32_t RCC_AHB1ENR_GPIOAEN_Msk = (0x1UL << RCC_AHB1ENR_GPIOAEN_Pos);   /*!< 0x00000001 */
constexpr uint32_t RCC_AHB1ENR_GPIOAEN     = RCC_AHB1ENR_GPIOAEN_Msk;
constexpr uint32_t RCC_AHB1ENR_GPIODEN_Pos = (3U);
constexpr uint32_t RCC_AHB1ENR_GPIODEN_Msk = (0x1UL << RCC_AHB1ENR_GPIODEN_Pos);   /*!< 0x00000008 */
constexpr uint32_t RCC_AHB1ENR_GPIODEN     = RCC_AHB1ENR_GPIODEN_Msk;



constexpr uint16_t GPIO_PIN_9   = ((uint16_t)0x0200);  /* Pin 9 selected    */
constexpr uint16_t GPIO_PIN_10  = ((uint16_t)0x0400);  /* Pin 10 selected   */


constexpr uint32_t CLK_Pin         = GPIO_PIN_9;
constexpr uint32_t DIO_Pin         = GPIO_PIN_10;

constexpr uint32_t CLK_Pin_Num = 9;
constexpr uint32_t DIO_Pin_Num = 10;

constexpr uint32_t  GPIO_SPEED_FREQ_LOW = 0x00000000U;  /*!< IO works at 2 MHz, please refer to the product datasheet */

constexpr uint32_t  GPIO_PULLUP   = 0x00000001U;   /*!< Pull-up activation                  */




//Non-STM32 macro
constexpr uint32_t  GPIO_MODE_OUTPUT = 0x00000001U;   /*!< Output Push Pull Mode                 */

constexpr uint32_t RCC_APB1ENR_TIM2EN_Pos = (0U);
constexpr uint32_t RCC_APB1ENR_TIM2EN_Msk = (0x1UL << RCC_APB1ENR_TIM2EN_Pos);    /*!< 0x00000001 */
constexpr uint32_t RCC_APB1ENR_TIM2EN = RCC_APB1ENR_TIM2EN_Msk;


constexpr uint32_t TIM_CR1_ARPE_Pos = (7U);
constexpr uint32_t TIM_CR1_ARPE_Msk = (0x1UL << TIM_CR1_ARPE_Pos);                   /*!< 0x00000080 */
constexpr uint32_t TIM_CR1_ARPE     = TIM_CR1_ARPE_Msk;                             /*!<Auto-reload preload enable     */

constexpr uint32_t TIM_CR1_CKD_Pos = (8U);
constexpr uint32_t TIM_CR1_CKD_Msk = (0x3UL << TIM_CR1_CKD_Pos);                    /*!< 0x00000300 */
constexpr uint32_t TIM_CR1_CKD     = TIM_CR1_CKD_Msk;                              /*!<CKD[1:0] bits (clock division) */

constexpr uint32_t TIM_CR1_DIR_Pos = (4U);
constexpr uint32_t TIM_CR1_DIR_Msk = (0x1UL << TIM_CR1_DIR_Pos);                    /*!< 0x00000010 */
constexpr uint32_t TIM_CR1_DIR     = TIM_CR1_DIR_Msk;                              /*!<Direction             */

constexpr uint32_t TIM_CR1_CMS_Pos = (5U);
constexpr uint32_t TIM_CR1_CMS_Msk = (0x3UL << TIM_CR1_CMS_Pos);                    /*!< 0x00000060 */
constexpr uint32_t TIM_CR1_CMS     = TIM_CR1_CMS_Msk;                              /*!<CMS[1:0] bits (Center-aligned mode selection) */

constexpr uint32_t TIM_CR1_OPM_Pos = (3U);
constexpr uint32_t TIM_CR1_OPM_Msk = (0x1UL << TIM_CR1_OPM_Pos);                    /*!< 0x00000008 */
constexpr uint32_t TIM_CR1_OPM     = TIM_CR1_OPM_Msk;                              /*!<One pulse mode        */

constexpr uint32_t TIM_SMCR_ETF_Pos = (8U);
constexpr uint32_t TIM_SMCR_ETF_Msk = (0xFUL << TIM_SMCR_ETF_Pos);                   /*!< 0x00000F00 */
constexpr uint32_t TIM_SMCR_ETF     = TIM_SMCR_ETF_Msk;                             /*!<ETF[3:0] bits (External trigger filter) */

constexpr uint32_t TIM_SMCR_ETPS_Pos = (12U);
constexpr uint32_t TIM_SMCR_ETPS_Msk = (0x3UL << TIM_SMCR_ETPS_Pos);                  /*!< 0x00003000 */
constexpr uint32_t TIM_SMCR_ETPS     = TIM_SMCR_ETPS_Msk;                            /*!<ETPS[1:0] bits (External trigger prescaler) */

constexpr uint32_t TIM_SMCR_ECE_Pos = (14U);
constexpr uint32_t TIM_SMCR_ECE_Msk = (0x1UL << TIM_SMCR_ECE_Pos);                   /*!< 0x00004000 */
constexpr uint32_t TIM_SMCR_ECE     = TIM_SMCR_ECE_Msk;                             /*!<External clock enable     */

constexpr uint32_t TIM_SMCR_ETP_Pos = (15U);
constexpr uint32_t TIM_SMCR_ETP_Msk = (0x1UL << TIM_SMCR_ETP_Pos);                   /*!< 0x00008000 */
constexpr uint32_t TIM_SMCR_ETP     = TIM_SMCR_ETP_Msk;                             /*!<External trigger polarity */

constexpr uint32_t TIM_SMCR_SMS_Pos = (0U);
constexpr uint32_t TIM_SMCR_SMS_Msk = (0x7UL << TIM_SMCR_SMS_Pos);                   /*!< 0x00000007 */
constexpr uint32_t TIM_SMCR_SMS     = TIM_SMCR_SMS_Msk;                             /*!<SMS[2:0] bits (Slave mode selection)    */

constexpr uint32_t TIM_SMCR_TS_Pos = (4U);
constexpr uint32_t TIM_SMCR_TS_Msk = (0x7UL << TIM_SMCR_TS_Pos);                    /*!< 0x00000070 */
constexpr uint32_t TIM_SMCR_TS     = TIM_SMCR_TS_Msk;                              /*!<TS[2:0] bits (Trigger selection)        */

constexpr uint32_t TIM_SMCR_MSM_Pos = (7U);
constexpr uint32_t TIM_SMCR_MSM_Msk = (0x1UL << TIM_SMCR_MSM_Pos);                   /*!< 0x00000080 */
constexpr uint32_t TIM_SMCR_MSM     = TIM_SMCR_MSM_Msk;                             /*!<Master/slave mode                       */

constexpr uint32_t TIM_CR2_MMS_Pos = (4U);
constexpr uint32_t TIM_CR2_MMS_Msk = (0x7UL << TIM_CR2_MMS_Pos);                    /*!< 0x00000070 */
constexpr uint32_t TIM_CR2_MMS     = TIM_CR2_MMS_Msk;                              /*!<MMS[2:0] bits (Master Mode Selection) */
constexpr uint32_t TIM_CR2_MMS_1   = (0x2UL << TIM_CR2_MMS_Pos);                    /*!< 0x0020 */

constexpr uint32_t TIM_EGR_UG_Pos = (0U);
constexpr uint32_t TIM_EGR_UG_Msk = (0x1UL << TIM_EGR_UG_Pos);                     /*!< 0x00000001 */
constexpr uint32_t TIM_EGR_UG     = TIM_EGR_UG_Msk;                               /*!<Update Generation                         */

constexpr uint32_t TIM_DIER_UIE_Pos = (0U);
constexpr uint32_t TIM_DIER_UIE_Msk = (0x1UL << TIM_DIER_UIE_Pos);                   /*!< 0x00000001 */
constexpr uint32_t TIM_DIER_UIE     = TIM_DIER_UIE_Msk;                             /*!<Update interrupt enable */

constexpr uint32_t TIM_CR1_CEN_Pos = (0U);
constexpr uint32_t TIM_CR1_CEN_Msk = (0x1UL << TIM_CR1_CEN_Pos);                    /*!< 0x00000001 */
constexpr uint32_t TIM_CR1_CEN     = TIM_CR1_CEN_Msk;                              /*!<Counter enable        */

constexpr uint32_t TIM_AUTORELOAD_PRELOAD_DISABLE = 0x00000000U;               /*!< TIMx_ARR register is not buffered */
constexpr uint32_t TIM_COUNTERMODE_UP             = 0x00000000U;                          /*!< Counter used as up-counter   */
constexpr uint32_t TIM_CLOCKDIVISION_DIV1         = 0x00000000U;                          /*!< Clock division: tDTS=tCK_INT   */
constexpr uint32_t TIM_OPMODE_SINGLE              = TIM_CR1_OPM;                          /*!< Counter stops counting at the next update event */
constexpr uint32_t TIM_MASTERSLAVEMODE_DISABLE = 0x00000000U;                          /*!< Master/slave mode is selected */
constexpr uint32_t TIM_TRGO_UPDATE = TIM_CR2_MMS_1;                                    /*!< Update event is used as trigger output (TRGO)                 */
constexpr uint32_t TIM_IT_UPDATE = TIM_DIER_UIE;                         /*!< Update interrupt            */


constexpr uint32_t TIM2_IRQn = 28;     /*!< TIM2 global Interrupt                                             */

inline void modify_reg( __IO uint32_t &reg,
                        uint32_t const clearmask,
                        uint32_t const setmask) __attribute__((always_inline));

inline void modify_reg( __IO uint32_t &reg,
                        uint32_t const clearmask,
                        uint32_t const setmask){
  reg = (reg & ~clearmask) | setmask;
}

inline volatile void sleep_us( uint32_t const us) __attribute__((always_inline));

// The code do not consider execution speed of the code itself
// That would be a hard task considering all the optimization
// modes and it's not really critical anyway
inline volatile void sleep_us( uint32_t const us) {
	constexpr uint32_t TIM2_IRQn_ICPR_index = TIM2_IRQn >> 5UL;
	constexpr uint32_t TIM2_IRQn_ICPR_bit = 1UL << (TIM2_IRQn & 0x1FUL);
	TIM2->ARR = us-1;
	TIM2->SR &= ~TIM_IT_UPDATE;
	NVIC->ICPR[TIM2_IRQn_ICPR_index] |= TIM2_IRQn_ICPR_bit;
	TIM2->CR1 = (TIM_CR1_CEN);
	__asm volatile ("sev");
	__asm volatile ("wfe");
	__asm volatile ("wfe");

}

//The question forbid recursion.
/*template<typename Pin>
constexpr uint32_t pin_2bit_pattern (uint32_t pattern, Pin pin){
    return (pattern & 0b11u) << (pin * 2u);
}

template<typename Pin,  typename ... Pins>
constexpr uint32_t pin_2bit_pattern (uint32_t pattern, Pin pin, Pins ... pins){
    return pin_2bit_pattern(pattern, pin) | pin_2bit_pattern(pattern, pins ...);
}*/

constexpr uint32_t pin_2bit_pattern (uint32_t pattern, uint32_t pin1, uint32_t pin2){
    return ( (pattern & 0b11u) << (pin1 * 2u) ) | ( (pattern & 0b11u) << (pin2 * 2u) );
}

constexpr uint32_t pin_2bit_pattern (uint32_t pattern, uint32_t pin1, uint32_t pin2,
								                       uint32_t pin3, uint32_t pin4){
	return ( (pattern & 0b11u) << (pin1 * 2u) ) | ( (pattern & 0b11u) << (pin2 * 2u) )
		 | ( (pattern & 0b11u) << (pin3 * 2u) ) | ( (pattern & 0b11u) << (pin4 * 2u) );
}

constexpr uint32_t pin_2bit_pattern (uint32_t pattern, uint32_t pin1, uint32_t pin2,
								                       uint32_t pin3, uint32_t pin4,
													   uint32_t pin5, uint32_t pin6){
	return ( (pattern & 0b11u) << (pin1 * 2u) ) | ( (pattern & 0b11u) << (pin2 * 2u) )
		 | ( (pattern & 0b11u) << (pin3 * 2u) ) | ( (pattern & 0b11u) << (pin4 * 2u) )
		 | ( (pattern & 0b11u) << (pin5 * 2u) ) | ( (pattern & 0b11u) << (pin6 * 2u) );
}

constexpr uint8_t ADDR_AUTO = 0x40;
//constexpr uint8_t ADDR_FIXED = 0x44;

constexpr uint8_t STARTADDR = 0xc0;

inline void start(void) __attribute__((always_inline));
inline void start(void)
{
	constexpr uint32_t CLK_Pin         = GPIO_PIN_9;
	constexpr uint32_t DIO_Pin         = GPIO_PIN_10;
	GPIOD->BSRR = CLK_Pin; //High level
	sleep_us(6);
	GPIOD->BSRR = DIO_Pin;
	sleep_us(6);
	GPIOD->BSRR = DIO_Pin << 16U; //Low level
	sleep_us(6);
	GPIOD->BSRR = CLK_Pin << 16U;
}

inline void stop(void) __attribute__((always_inline));
inline void stop(void)
{
	GPIOD->BSRR = CLK_Pin << 16U;
	sleep_us(6);
	GPIOD->BSRR = DIO_Pin << 16U; //Low level
	sleep_us(6);
	GPIOD->BSRR = CLK_Pin; //High level
	sleep_us(6);
	GPIOD->BSRR = DIO_Pin;
}


inline void writeBit(uint8_t &wr_data) __attribute__((always_inline));
inline void writeBit(uint8_t &wr_data){
	GPIOD->BSRR = CLK_Pin << 16U;

	/*if(wr_data & 0x01) { GPIOD->BSRR = DIO_Pin; }
	else {GPIOD->BSRR = DIO_Pin << 16U;}*/
	GPIOD->BSRR = DIO_Pin << ((1-(wr_data & 0x01))*16U);

	sleep_us(6);
	wr_data >>= 1;
	GPIOD->BSRR = CLK_Pin;
	sleep_us(8);

	GPIOD->BSRR = CLK_Pin << 16U;
}

inline void writeByte(uint8_t wr_data) __attribute__((always_inline));
inline void writeByte(uint8_t wr_data)
{
  //auto GPIOD = reinterpret_cast<GPIO_TypeDef * const>(GPIOD_BASE);
  //uint8_t count = 0;
  writeBit(wr_data);
  writeBit(wr_data);
  writeBit(wr_data);
  writeBit(wr_data);

  writeBit(wr_data);
  writeBit(wr_data);
  writeBit(wr_data);
  writeBit(wr_data);

sleep_us(6);
GPIOD->BSRR = CLK_Pin;
sleep_us(16);
}

struct DispData{
    uint8_t one;
    uint8_t two;
    uint8_t three;
    uint8_t four;
};

inline void display_mass(DispData const &data) __attribute__((always_inline));
inline void display_mass(DispData const &data)
{
    constexpr uint8_t Cmd_DispCtrl = 0x88 + 0x07;

	start();
	writeByte(ADDR_AUTO);
	stop();
	start();
	writeByte(STARTADDR);
    writeByte(data.one);
    writeByte(data.two);
    writeByte(data.three);
    writeByte(data.four);

	stop();
	start();
	writeByte(Cmd_DispCtrl);
	stop();
}

constexpr DispData from_number(uint32_t number){
	DispData result{0,0,0,0};
	uint8_t TubeTab[] = {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f, 0x77,0x7c,0x40}; //0~9, A(10), b(11), -(12)
	if(0 < number && number < 10 ){
		result.four = TubeTab[number % 10] ;
		result.three = 0;
		result.two = 0;
		result.one = 0;
	}

	if(10 <= number && number < 100 ){
		result.four = TubeTab[number % 10];
		result.three = TubeTab[number / 10];
		result.two = 0;
		result.one = 0;
	}

	if(number == 100){
		result.four = TubeTab[0];
		result.three = TubeTab[0];
		result.two = TubeTab[1];
		result.one = 0;
	}

	return result;
}


int main(void)
{
	FLASH->ACR |= FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN;
	(RCC->APB1ENR) |= (RCC_APB1ENR_PWREN);
	{ /* Delay after an RCC peripheral clock enabling */
		__IO auto tmpreg __attribute__ ((unused)) = ((RCC->APB1ENR) & (RCC_APB1ENR_PWREN)); //delay
	}

	// default voltage stabilizer
	modify_reg(PWR->CR, PWR_CR_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
	// Internal oscillator default calibration
	modify_reg(RCC->CR, RCC_CR_HSITRIM, RCC_HSICALIBRATION_DEFAULT << RCC_CR_HSITRIM_Pos);

	// Setting internal dividers to maximum, just in case
	modify_reg(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
	modify_reg(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));

	// Setting sysclock divider and selecting internal oscillator
	modify_reg(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
	modify_reg(RCC->CFGR, RCC_CFGR_SW, (RCC_SYSCLKSOURCE_HSI));

	// Setting periferal dividers to what we actually need
	modify_reg(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV2);
	modify_reg(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV1);

	RCC->AHB1ENR = RCC_AHB1ENR_GPIOAEN;
	{ /* Delay after an RCC peripheral clock enabling */
	    __IO auto tmpreg __attribute__ ((unused)) = ((RCC->AHB1ENR) & (RCC_AHB1ENR_GPIOAEN));
	}
	RCC->AHB1ENR = RCC_AHB1ENR_GPIODEN;
	{
	    __IO auto tmpreg __attribute__ ((unused)) = ((RCC->AHB1ENR) & (RCC_AHB1ENR_GPIODEN));
	}

	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	{
		__IO auto tmpreg __attribute__((unused)) = RCC->APB1ENR & RCC_APB1ENR_TIM2EN;
	}
	modify_reg(TIM2->CR1, (TIM_CR1_ARPE| TIM_CR1_CKD | TIM_CR1_DIR | TIM_CR1_CMS | TIM_CR1_OPM ),
			(TIM_AUTORELOAD_PRELOAD_DISABLE | TIM_COUNTERMODE_UP | TIM_CLOCKDIVISION_DIV1 | TIM_OPMODE_SINGLE));
	modify_reg(TIM2->SMCR, (TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP | TIM_SMCR_SMS | TIM_SMCR_TS | TIM_SMCR_MSM),
					(TIM_MASTERSLAVEMODE_DISABLE));
	modify_reg(TIM2->CR2, TIM_CR2_MMS, TIM_TRGO_UPDATE);

	TIM2->PSC = 15;
	/* Generate an update event to reload the Prescaler
	    value immediately */
	TIM2->EGR = TIM_EGR_UG;
	/* Note: iterrupt is not enabled in NVIC
	   That means we got an event to wake up
	   without the interrupt itself*/
	TIM2->DIER |= TIM_IT_UPDATE;
	SCB->SCR |= SCB_SCR_SEVONPEND_Msk;

	GPIOD->BSRR = (CLK_Pin|DIO_Pin) << 16U;

	constexpr uint32_t pins_2bit_mask_d = pin_2bit_pattern(0b11, CLK_Pin_Num, DIO_Pin_Num);
	constexpr uint32_t pins_mask_d = CLK_Pin | DIO_Pin ;

	//Pin output speed
	constexpr uint32_t speeds_d = pin_2bit_pattern(GPIO_SPEED_FREQ_LOW, CLK_Pin_Num, DIO_Pin_Num);
	modify_reg(GPIOD->OSPEEDR, pins_2bit_mask_d, speeds_d);

	constexpr uint32_t open_drain_pins_d = CLK_Pin | DIO_Pin;
	//non-open drain pins are push-pull ones
	modify_reg(GPIOD->OTYPER, pins_mask_d, open_drain_pins_d);


	constexpr uint32_t pullups_d = pin_2bit_pattern(GPIO_PULLUP, CLK_Pin_Num, DIO_Pin_Num);
	modify_reg(GPIOD->PUPDR, pins_2bit_mask_d, pullups_d);

	constexpr uint32_t outputs_d = pin_2bit_pattern(GPIO_MODE_OUTPUT, CLK_Pin_Num, DIO_Pin_Num);
	modify_reg(GPIOD->MODER, pins_2bit_mask_d, outputs_d);
	//Disabling SysTick

	constexpr uint32_t start_line = __LINE__;
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));
	sleep_us(400'000); display_mass(from_number(__LINE__-start_line));


	__asm volatile ("sev");
	__asm volatile ("wfe");
	__asm volatile ("wfe");
}
